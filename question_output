from selenium import webdriver
from selenium.webdriver.common.by import By
from backoff import expo
from logging import DEBUG, basicConfig, debug
from tkinter import simpledialog
from time import sleep
import main

basicConfig(level=DEBUG)
driver = webdriver.Edge()
try:
    main.open_web(driver)
    main.on_predicate(wait_gen=expo, predicate=lambda x: not x)
    main.safe_click(driver, "ç™»å…¥")

    @main.function_logger
    def user_ui():
        global chapter_list
        from selenium.webdriver.support.ui import WebDriverWait
        from selenium.webdriver.support import expected_conditions as EC
        from selenium.webdriver.common.by import By
        from bs4 import BeautifulSoup
        # æ‰“é–‹ç¶²é ä¸¦åŸ·è¡Œä¸€äº›æ“ä½œ
        main.safe_click(driver, "é¸æ“‡ç« ç¯€")
        final_url = driver.current_url  # æˆ–è€…ç­‰å¾…æŸå€‹ç‰¹å®šå…ƒç´ åŠ è¼‰å®Œæˆ

        # ç­‰å¾…ç›´åˆ°ç¶²é å…§å®¹åŠ è¼‰å®Œæˆ
        WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.TAG_NAME, 'body')))

        # ç²å–ç¶²é æºä»£ç¢¼
        html_source = driver.page_source

        # è§£æç¶²é å…§å®¹
        soup = BeautifulSoup(html_source, 'html.parser')

        # å°ˆæ³¨æ–¼è§£æç¬¬äºŒå€‹ table
        def extract_chapters_from_second_table(soup):
            tables = soup.find_all('table')
            if len(tables) < 2:
                return []  # å¦‚æœæ²’æœ‰è¶³å¤ çš„è¡¨æ ¼ï¼Œè¿”å›ç©ºåˆ—è¡¨

            second_table = tables[1]
            chapters = []
            for table_row in second_table.find_all('tr'):
                cells = table_row.find_all('td')
                if len(cells) >= 2:
                    chapter_number = cells[1].text.strip()
                    chapter_title = cells[2].text.strip()
                    chapters.append(f"{chapter_number}  {chapter_title}")
            return chapters
        
        def extract_all_chapters():
            chapters = []
            # å®šä½åˆ°ç¬¬ä¸‰å€‹ ul å…ƒç´ 
            pagination_ul = driver.find_elements(By.CSS_SELECTOR, 'ul')[2]
            page_numbers = pagination_ul.find_elements(By.TAG_NAME, 'li')[1:6]

            for i in range(len(page_numbers)):
                # é»æ“Šé ç¢¼
                page_numbers[i].click()
                
                # ç­‰å¾…é é¢åŠ è¼‰
                WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.TAG_NAME, 'body')))
                
                # æå–ç•¶å‰é é¢çš„ç« ç¯€è³‡æ–™
                soup = BeautifulSoup(driver.page_source, 'html.parser')
                chapters.extend(extract_chapters_from_second_table(soup))

                # é‡æ–°å®šä½åˆ°ç¬¬ä¸‰å€‹ ul å…ƒç´ ä¸¦æ›´æ–°é ç¢¼å…ƒç´ åˆ—è¡¨
                pagination_ul = driver.find_elements(By.CSS_SELECTOR, 'ul')[2]
                page_numbers = pagination_ul.find_elements(By.TAG_NAME, 'li')[1:6]


            return chapters
        
        chapter_list = extract_all_chapters()

    def ui():
        import tkinter as tk
        from tkinter import Toplevel, Frame, Checkbutton, StringVar
        def open_selection_window():
            global chapter_vars  # ä½¿ç”¨å…¨å±€è®Šé‡ä¾†ä¿å­˜å‹¾é¸æ¡†çš„ç‹€æ…‹

            selection_window = Toplevel(window)
            selection_window.title("é¸æ“‡ç« ç¯€")
            selection_window.geometry("+{}+{}".format(window.winfo_x() + 200, window.winfo_y() + 50))

            chapters_per_page = 10
            total_chapters = 48
            options = chapter_list

            pages = []
            chapter_vars = {}
            for i in range(0, total_chapters, chapters_per_page):
                frame = Frame(selection_window)
                pages.append(frame)
                for j in range(i, min(i + chapters_per_page, total_chapters)):
                    var = StringVar(value="0")
                    if options[j] in selected_options:  # å¦‚æœç« ç¯€å·²è¢«é¸æ“‡ï¼Œé è¨­ç‚ºå‹¾é¸
                        var.set("1")
                    chk = Checkbutton(frame, text=options[j], variable=var)
                    chk.pack()
                    chapter_vars[options[j]] = var

            def show_page(index):
                for frame in pages:
                    frame.pack_forget()
                pages[index].pack()

            # é ç¢¼æŒ‰éˆ•
            page_buttons_frame = Frame(selection_window)
            for i in range(len(pages)):
                btn = tk.Button(page_buttons_frame, text=str(i + 1), command=lambda i=i: show_page(i))
                btn.pack(side=tk.LEFT)
            page_buttons_frame.pack(side=tk.TOP)

            # åº•éƒ¨æŒ‰éˆ•
            bottom_buttons_frame = Frame(selection_window)

            # ç¢ºèªæŒ‰éˆ•
            confirm_btn = tk.Button(bottom_buttons_frame, text="ç¢ºèª", command=lambda: submit_and_close(selection_window, chapter_vars))
            confirm_btn.pack(side=tk.LEFT)

            # å–æ¶ˆæŒ‰éˆ•
            cancel_btn = tk.Button(bottom_buttons_frame, text="å–æ¶ˆ", command=selection_window.destroy)
            cancel_btn.pack(side=tk.LEFT)

            bottom_buttons_frame.pack(side=tk.BOTTOM)

            show_page(0)  # é¡¯ç¤ºç¬¬ä¸€é 

        def submit_and_close(selection_window, chapter_vars):
            submit_selections(chapter_vars)
            selection_window.destroy()

        def submit_selections(chapter_vars):
            for chapter, var in chapter_vars.items():
                if var.get() == "1":
                    if chapter not in selected_options:
                        add_selected_option(chapter)
                elif chapter in selected_options:
                    remove_selected_option(chapter)

        def add_selected_option(option_text):
            def remove_option():
                option_frame.destroy()
                del selected_options[option_text]
                chapter_vars[option_text].set("0")  # æ›´æ–°å‰¯è¦–çª—ä¸­çš„å‹¾é¸æ¡†

            option_frame = tk.Frame(window)
            option_frame.pack()

            tk.Label(option_frame, text=option_text).pack(side=tk.LEFT)
            remove_btn = tk.Button(option_frame, text="å–æ¶ˆ", command=remove_option)
            remove_btn.pack(side=tk.LEFT)

            selected_options[option_text] = option_frame

        def remove_selected_option(option_text):
            selected_options[option_text].destroy()
            del selected_options[option_text]

        window = tk.Tk()
        window.title("ä¸»è¦–çª—")
        window.geometry("300x200")

        selected_options = {}
        chapter_vars = {}

        chapter_btn = tk.Button(window, text="ç« ç¯€", command=open_selection_window)
        chapter_btn.pack()

        window.mainloop()

    course = simpledialog.askstring("course name", "Please enter a courseğŸ“š:")
    if course == "":
        course = "Test"
    main.on_stale_element_reference_exception(
        lambda: next(
            div
            for div in driver.find_elements(By.TAG_NAME, "div")
            if course == div.text
        ).click()
    )()
    sleep(1)
    driver.find_elements(By.CLASS_NAME, "semi-navigation-item-text")[1].click()
    chapter_list = []
    user_ui()
    #print(chapter_list)
    ui()
    driver.quit()
finally:
    pass
